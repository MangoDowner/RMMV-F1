# 03.重写方法预备知识教学
``重写方法``重写指的是对系统原函数的重写，
重写方法的目的在于改变系统原函数的作用或者快速制作出与原函数功能类似的函数

## 3.1 什么是方法
其实这个应该属于语法上的知识，由于非常重要，
所以我结合RPG MAKER来讲基于对象的方法及与其有关的属性，参数，加深大家的理解。

参数如果有JavaScript语言基础，就会知道，获得对象一般是先写出一个构造函数，然后使用``new<对象名><(实参表)>``来建立。
```js
Person = function(name,number) {
    this._name =name;
    this._number=number;
    this._country="中国";
    this._age;
};
var sunWuKong=new Person("孙悟空","1");
```
我随便设计一个构造函数，简单解释一下：
Person既可以是一个普通函数，也可以是一个构造函数，这取决你如何使用它，
如果你要使用它建立一个对象，它就是构造函数
（有个不成文的规则，如果是构造函数，首字母大写，如果是普通函数，按照通用的驼峰命名法命名）。
当你使用new创建对象时，传入的实参``name``和``number``就是这个对象的参数。

还是利用上面的例子，Peron类需要使用参数创建对象，之后获得的对象一定会有属性，
这些属性包括使用实参初始化的，比如``name``和``number``，也包括默认值如``country``，
还包括定义但是未赋值的变量``age``。它们一起构成了这个对象的属性。

有些对象，是能做一些事情的，这些就称作对象的方法，方法，我们一般在构造函数外定义。
```js
Person.skill = function(){
    alert("我是"+name);
} 
sunWuKong.skill();   // //输出“我是孙悟空” 
```
显而易见，方法就是这个对象所带有的函数。

## 3.2 RPGMAKER内部对象如何管理方法？
首先再复习一遍原型链的知识，对我们来说，知道原型链就是一种对父类方法和属性的继承，迭代的过程，
对象通过原型链向上可以使用父类的属性和方法，向下可以创建自己的子类就够了。（想了解更多请查阅相关文章）

可以说RM中对象及其方法的构建是极其有逻辑的，我们还是拿管家类（Manager）来作为例子

很显然，你家的管家不是天生就有的，管家刚出生时，还和所有人一样，是个什么都不会的孩子，不过他有父母。

他的父亲（Manager对象）会教会他一些最基本，生存所需的知识，这些知识就通过原型链传递给了管家，于是管家从父亲那里继承了：
+ 1.都是人（都是同一种对象）
+ 2.都会做一些所有对象都会做的事（这些事就来自祖宗对象"Object“，其资料可以在W3School上查到)；

这个孩子长大了，想要另立门户，于是他通过学习知识，掌握了一些关于管理物品的方法，所以他决定给自己起一个新名字，叫做``物品管家``
```js
function ObjectManager() {
    this.initialize.apply(this, arguments);
}

ObjectManager.prototype = Object.create(Manager.prototype);
ObjectManager.prototype.constructor = ObjectManager;

ObjectManager.prototype.initialize = function() {
    Manager.prototype.initialize.call(this);     //物品管家继承了他父亲的原型链
    this.skill ();   //物品管家自己学会的新技能
};

ObjectManager.skill = function() {
    alert("我是物品管家");
}
```

在这之后物品管家就是一个新的对象了，他可以通过原型链找到他父亲的方法，同时也有自己的方法skill。

好了，肯定有小朋友要问，为什么搞这么复杂呢，用一个管家解决所有问题不是就不用继承那么多次了吗？

其实，我们不断继承细分，就是为了方法好找，
制作一个游戏所需要的方法之多，不能一步就找到，就好像你不能从一张中国地图找到一个人一样，
你一定得先找到哪个省，哪个市，哪条路，哪个门牌，最终找到人，
代码中对象不断继承，也是为了方便找到自己需要的方法，同时避免平行方法太多导致代码难以调试。

## 补充：精灵对象的原型链
通过学习这条原型链，大家可以对原型继承有更加深入的理解，对为什么要通过原型链细分方法有更深的认识。

+ 祖先：永远是Object
+ 第二代：Spirte 精灵
+ 第三代：Sprite_Base 基础精灵
+ 第四代：Sprite_Button 按钮精灵 ， Sprite_Character角色精灵，
Sprite_Battler 战斗精灵，Sprite_Actor角色精灵，Sprite_Enemy敌人精灵，
插件中由其它继承而来的自定义精灵…
+ 第五代：精灵实
